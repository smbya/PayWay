# Payment Gateway Service

## Описание

Данный проект представляет собой асинхронный платёжный шлюз, предназначенный для приёма, обработки и отслеживания жизненного цикла платежей при работе с внешними платёжными провайдерами.

Сервис спроектирован как внутренний backend-компонент, ориентированный на надёжность, масштабируемость и наблюдаемость.  

---

## Общая архитектура

Система состоит из следующих компонентов:

- API Service — HTTP сервис для работы с платежами
- Callback Service — HTTP сервис для обработки вебхуков от провайдеров (может быть частью API)
- Worker Service — фоновый обработчик команд и событий
- Projection Service — компонент обновления состояния в БД (может быть частью Worker)
- Kafka — транспорт команд и событий
- PostgreSQL — хранение текущего состояния и истории
- Jaeger — распределённый трейсинг
- Prometheus — сбор метрик
- Grafana — визуализация и мониторинг

Все компоненты запускаются локально через Docker Compose.

---

## Основные принципы

- HTTP API не изменяет состояние платежа напрямую
- Все изменения состояния происходят асинхронно через события
- Система должна быть устойчива к дубликатам и повторной доставке
- Observability является обязательным требованием, а не опцией
- PostgreSQL используется как проекция состояния, а не как источник истины

---

## Поток обработки платежа

1. Клиент отправляет HTTP-запрос на создание платежа
2. API Service валидирует запрос и публикует команду в Kafka
3. Worker Service получает команду и инициирует обработку
4. Worker взаимодействует с внешним платёжным провайдером
5. Результат обработки фиксируется в виде события
6. Событие обновляет текущее состояние платежа
7. Клиент может запросить актуальный статус платежа через API

Обработка платежа может занимать продолжительное время и проходить через несколько промежуточных состояний.

---

## Состояния платежа

Минимальный набор состояний платежа:

- NEW — платёж создан, но ещё не обработан
- PROCESSING — платёж находится в обработке
- COMPLETED — платёж успешно завершён
- FAILED — платёж завершён с ошибкой
- CANCELED — платёж отменён

Переходы между состояниями должны быть строго контролируемыми и валидируемыми.

---

## Kafka

Kafka используется для передачи команд и событий между компонентами системы.

Ожидается наличие как минимум двух логических потоков:

- команды — намерения изменить состояние платежа
- события — факты, произошедшие в системе

Система должна корректно работать при:

- повторной доставке сообщений
- дублирующихся командах
- нарушении порядка сообщений

---

## Worker Service

Worker Service отвечает за:

- чтение команд из Kafka
- загрузку текущего состояния платежа
- применение бизнес-логики и правил перехода состояний
- взаимодействие с внешними платёжными провайдерами
- публикацию событий в Kafka
- обработку ошибок и повторных попыток

Worker не принимает HTTP-запросы и работает исключительно асинхронно.

---

## Хранилище данных

PostgreSQL используется для хранения:

- текущего состояния платежей
- истории событий
- технических метаданных и служебной информации

Структура данных должна позволять восстановить состояние платежа и проанализировать его жизненный цикл.

---

## Observability

### Tracing

- каждый платёж должен иметь единый trace
- все ключевые этапы обработки должны быть видны в Jaeger
- trace должен связывать API, worker и интеграции

### Metrics

Минимальный набор метрик:

- количество созданных платежей
- количество успешных и неуспешных платежей
- время обработки платежей
- количество повторных попыток
- количество ошибок по типам

Метрики должны собираться Prometheus и визуализироваться в Grafana.

---

## Запуск проекта

Для запуска всех компонентов используется Docker Compose.

Проект должен полностью запускаться одной командой:

```bash
docker compose up
```

После запуска должны быть доступны:

- HTTP API сервиса
- Kafka и worker-обработка
- Jaeger для просмотра трейсов
- Prometheus для сбора метрик
- Grafana с преднастроенными дашбордами
- Тестовый клиент

---

## Тестирование

Проект должен позволять:

- вручную создавать платежи через HTTP-запросы
- отслеживать изменения их состояния
- наблюдать асинхронную обработку
- анализировать трассировки и метрики

Тестирование предполагается ручное, через HTTP-клиент и интерфейсы observability-инструментов.

---

## Ожидаемый результат

По итогам выполнения задания должен быть реализован:

- работающий асинхронный платёжный шлюз
- понятная архитектура и структура проекта
- полноценная observability-инфраструктура
